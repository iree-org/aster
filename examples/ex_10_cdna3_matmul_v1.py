"""
Saturating the MATRIX unit
==========================

Example usage:
python ex_10_cdna3_matmul_v1.py --output test.hsaco --mcpu gfx942 \
    --m-regs 1 --n-regs 1 --k-regs 1 --num-vgprs=12 --dump-ir --dump-asm

python ex_10_cdna3_matmul_v1.py --output test.hsaco --mcpu gfx942 \
    --m-regs 4 --n-regs 4 --k-regs 4 --num-vgprs=132

python ex_10_cdna3_matmul_v1.py --output test.hsaco --mcpu gfx942 \
    --m-regs 4 --n-regs 4 --k-regs 4 --num-vgprs=132 --use-relocatable-registers

Note: v_mfma_f32_16x16x16_f16 requires 2 VGPRs for A and B operands, 4 VGPRs for C accumulator.
      Default kernel name is "kernel", override with --kernel-name <name>.
"""

import itertools

from aster import ir
from aster.dialects import api
from aster.dialects.api import s_waitcnt
from kernel_utils import (
    VRegRangeArray,
    allocate_indexing_vgprs,
    setup_indexing_registers,
    setup_matmul_arrays,
)


def _execute_matmul_v1_preload(
    ctx: "ir.Context",  # type: ignore
    A: VRegRangeArray,
    B: VRegRangeArray,
    C: VRegRangeArray,
    indexing_vgprs: list,
) -> None:
    # Extract dimensions from array shapes
    m_regs, k_regs = A.shape
    assert B.shape == (k_regs, C.shape[1]), "B shape must match (k_regs, n_regs)"
    n_regs = C.shape[1]

    # Preload all data
    for m, k in itertools.product(range(m_regs), range(k_regs)):
        a, inc_a = A.get((m, k))
    for k, n in itertools.product(range(k_regs), range(n_regs)):
        b, inc_b = B.get((k, n))
    for m, n in itertools.product(range(m_regs), range(n_regs)):
        c, inc_c = C.get((m, n))

    # Wait for all loads to complete
    s_waitcnt(vmcnt=0, lgkmcnt=0)

    # Perform MFMA operations: C = A * B + C
    for k, m, n in itertools.product(range(k_regs), range(m_regs), range(n_regs)):
        c, inc_c = C.get((m, n))
        a, inc_a = A.get((m, k))
        b, inc_b = B.get((k, n))
        C[m, n] = api.v_mfma_f32_16x16x16_f16(c, a, b, c)  # type: ignore


def _inject_matmul_v1_preload(
    ctx: "ir.Context",  # type: ignore
    sgprs: list,
    vgprs: list,
    agprs: list,
    num_iterations: int,
    *,
    operand_register_size: int = 2,
    accum_register_size: int = 4,
    m_regs: int = 4,
    n_regs: int = 4,
    k_regs: int = 4,
) -> None:
    lds_sizes = [8192, 8192, 8192]

    unused_sgprs, unused_vgprs, unused_agprs, A, B, C = setup_matmul_arrays(
        ctx,
        sgprs,
        vgprs,
        operand_register_size,
        accum_register_size,
        m_regs,
        n_regs,
        k_regs,
        lds_sizes,
    )
    sgprs, vgprs = unused_sgprs, unused_vgprs

    # Allocate indexing registers
    num_indexing_regs = setup_indexing_registers()
    indexing_vgprs, unused_vgprs = allocate_indexing_vgprs(
        ctx, unused_vgprs, num_indexing_regs
    )
    vgprs = unused_vgprs

    _execute_matmul_v1_preload(ctx, A, B, C, indexing_vgprs)  # type: ignore[arg-type]


if __name__ == "__main__":
    from ex_10_cdna3_matmul_cli import run_matmul_cli

    # Kernel args are automatically generated by run_matmul_cli if not provided
    run_matmul_cli(_inject_matmul_v1_preload)
